{"ast":null,"code":"let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid() {\n  let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 11;\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\nconst escapeRegexp = term => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, char => `\\\\${char}`);\nconst termsToRegExpString = terms => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = _ref => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref;\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = _ref2 => {\n  let {\n    terms,\n    matchExactly = false\n  } = _ref2;\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({\n      terms,\n      matchExactly\n    }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\nconst hasProp = prop => obj => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = chunk => typeof chunk !== \"undefined\";\nfunction clip(_ref3) {\n  let {\n    curr,\n    next,\n    prev,\n    clipBy = 3\n  } = _ref3;\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [...words.slice(0, clipBy), ellipsis, ...words.slice(-clipBy)].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasLength = str => str.length > 0;\nconst highlightWords = _ref4 => {\n  let {\n    text,\n    query,\n    clipBy,\n    matchExactly = false\n  } = _ref4;\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [{\n      key: uid(),\n      text,\n      match: false\n    }];\n  }\n  const searchRegexp = buildRegexp({\n    terms: query,\n    matchExactly\n  });\n  return text.split(searchRegexp).filter(hasLength).map(str => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === \"number\" && {\n    // We only overwrite the text if there is a clip\n    text: clip(__spreadProps(__spreadValues(__spreadValues({\n      curr: chunk\n    }, index < chunks.length - 1 && {\n      next: chunks[index + 1]\n    }), index > 0 && {\n      prev: chunks[index - 1]\n    }), {\n      // If this wasn't the first chunk, set the previous chunk\n      clipBy\n    }))\n  }));\n};\nexport { highlightWords as default };","map":{"version":3,"names":["IDX","HEX","toString","uid","len","arguments","length","undefined","str","num","Math","random","escapeRegexp","term","replace","char","termsToRegExpString","terms","split","join","regexpQuery","_ref","matchExactly","TypeError","escapedTerms","trim","buildRegexp","_ref2","fromString","exec","RegExp","e","hasProp","prop","obj","hasMatch","chunkExists","chunk","clip","_ref3","curr","next","prev","clipBy","words","text","match","ellipsis","slice","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","key","value","enumerable","configurable","writable","__spreadValues","a","b","call","__spreadProps","hasLength","highlightWords","_ref4","query","safeQuery","searchRegexp","filter","map","toLowerCase","test","index","chunks","default"],"sources":["C:/Users/shaha/OneDrive/שולחן העבודה/Project/KanfeiDror/node_modules/highlight-words/dist/highlight-words.mjs"],"sourcesContent":["let IDX = 36;\nlet HEX = \"\";\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n  let str = \"\";\n  let num = len;\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n  return str;\n}\n\nconst escapeRegexp = (term) => term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char) => `\\\\${char}`);\nconst termsToRegExpString = (terms) => terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({\n  terms,\n  matchExactly = false\n}) => {\n  if (typeof terms !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  const escapedTerms = escapeRegexp(terms.trim());\n  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({\n  terms,\n  matchExactly = false\n}) => {\n  try {\n    const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n    if (fromString) {\n      return new RegExp(fromString[2], fromString[3]);\n    }\n    return new RegExp(regexpQuery({ terms, matchExactly }), \"ig\");\n  } catch (e) {\n    throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n  }\n};\n\nconst hasProp = (prop) => (obj) => obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk) => typeof chunk !== \"undefined\";\nfunction clip({\n  curr,\n  next,\n  prev,\n  clipBy = 3\n}) {\n  const words = curr.text.split(\" \");\n  const len = words.length;\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  }\n  const ellipsis = \"...\";\n  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n    if (len > clipBy * 2) {\n      return [\n        ...words.slice(0, clipBy),\n        ellipsis,\n        ...words.slice(-clipBy)\n      ].join(\" \");\n    }\n    return curr.text;\n  }\n  if (chunkExists(next) && hasMatch(next)) {\n    return [ellipsis, ...words.slice(-clipBy)].join(\" \");\n  }\n  if (chunkExists(prev) && hasMatch(prev)) {\n    return [...words.slice(0, clipBy), ellipsis].join(\" \");\n  }\n  return curr.text;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasLength = (str) => str.length > 0;\nconst highlightWords = ({\n  text,\n  query,\n  clipBy,\n  matchExactly = false\n}) => {\n  const safeQuery = typeof query === \"string\" ? query.trim() : query;\n  if (safeQuery === \"\") {\n    return [\n      {\n        key: uid(),\n        text,\n        match: false\n      }\n    ];\n  }\n  const searchRegexp = buildRegexp({ terms: query, matchExactly });\n  return text.split(searchRegexp).filter(hasLength).map((str) => ({\n    // Compose the object for a match\n    key: uid(),\n    text: str,\n    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === \"number\" && {\n    // We only overwrite the text if there is a clip\n    text: clip(__spreadProps(__spreadValues(__spreadValues({\n      curr: chunk\n    }, index < chunks.length - 1 && { next: chunks[index + 1] }), index > 0 && { prev: chunks[index - 1] }), {\n      // If this wasn't the first chunk, set the previous chunk\n      clipBy\n    }))\n  }));\n};\n\nexport { highlightWords as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}